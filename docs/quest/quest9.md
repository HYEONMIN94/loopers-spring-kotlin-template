# 📝 Round 9 Quests

---

## 💻 Implementation Quest

> 이번에는 Redis ZSET 을 이용해 랭킹 시스템을 만들어 볼 거예요.
이전에 **Kafka Consumer** 를 통해 적재하던 집계정보를 기반으로 **실시간 랭킹 파이프라인을 구축**해봅니다.
>

<aside>
🎯

**Must-Have (이번 주에 무조건 가져가야 좋을 것-**무조건 ****하세요**)**

- Redis ZSET
- Realtime Ranking
- Ranking API

**Nice-To-Have (부가적으로 가져가면 좋을 것-**시간이 ****허락하면 ****꼭 ****해보세요**)**

- 초 실시간 (시간 단위) 랭킹 만들기
- 콜드 스타트 문제 해결
</aside>

### 📋 과제 정보

이전 주차에서 만들었던 `product_metrics` 테이블을 응용해 **카프카 컨슈머**에서 실시간 랭킹 집계를 시작합니다. 또한 이 랭킹 정보를 바탕으로 **오늘의 인기상품** API 를 만들어 봅니다.

![K-020.png](attachment:09de1aa1-d664-4e3e-82f0-dffa1db95716:K-020.png)

### (1) Kafka Consumer  → Redis ZSET 적재

- **카프카 배치 리스너**
    - 메세지 단건 처리는 너무 많은 ZSET 연산, DB 연산을 동반할 수 있으므로 배치 리스너를 이용해 애플리케이션에서 정제하고, 스루풋을 높이기
- 조회/좋아요/주문 이벤트 등을 컨슘해 일간 키 (e.g. `ranking:all:{yyyyMMdd}`) ZSET 에 점수를 누적합니다.
- 각 이벤트에 따라 적절한 **Weight** 및 **Score** 를 고민해보고 이를 기반으로 랭킹을 반영합니다.

    ```java
    e.g.
    조회 : Weight = 0.1 , Score = 1
    좋아요 : Weight = 0.2 , Score = 1
    주문 : Weight = 0.6 , Score = price * amount (정규화 시에는 log 적용도 가능)
    ```

- **ZSET 스펙**
    - `TTL` : 2Day
    - `KEY` : ranking:all:{yyyyMMdd}

### (2) Ranking API 구현

- 랭킹 Page 조회
    - GET `/api/v1/rankings?date=yyyyMMdd&size=20&page=1`
- 상품 상세 조회 시 해당 상품의 랭킹 정보 추가

### (Additionals) 너무 쉽다구요?

- **실시간 Weight 조절**
    - 점수 계산에 사용되는 Weight 를 어떻게 수정할 수 있을지 고민해보기
- **실시간 랭킹**
    - 일간 랭킹이 아닌, 1시간 단위 랭킹을 만들어보기
- **콜드 스타트 완화를 위한 Scheduler 구현**
    - 23시 50분에 Score Carry-Over 를 통해 미리 랭킹판 생성하기

---

## ✅ Checklist

### 📈 Ranking Consumer

- [ ]  랭킹 ZSET 의 TTL, 키 전략을 적절하게 구성하였다
- [ ]  날짜별로 적재할 키를 계산하는 기능을 만들었다
- [ ]  이벤트가 발생한 후, ZSET 에 점수가 적절하게 반영된다

### ⚾ Ranking API

- [ ]  랭킹 Page 조회 시 정상적으로 랭킹 정보가 반환된다
- [ ]  랭킹 Page 조회 시 단순히 상품 ID 가 아닌 상품정보가 Aggregation 되어 제공된다
- [ ]  상품 상세 조회 시 해당 상품의 순위가 함께 반환된다 (순위에 없다면 null)

---

## ✍️ Technical Writing Quest

> 이번 주에 학습한 내용, 과제 진행을 되돌아보며
**"내가 어떤 판단을 하고 왜 그렇게 구현했는지"** 를 글로 정리해봅니다.
>
>
> **좋은 블로그 글은 내가 겪은 문제를, 타인도 공감할 수 있게 정리한 글입니다.**
>
> 이 글은 단순 과제가 아니라, **향후 이직에 도움이 될 수 있는 포트폴리오** 가 될 수 있어요.
>

### 📚 Technical Writing Guide

### ✅ 작성 기준

| 항목 | 설명 |
| --- | --- |
| **형식** | 블로그 |
| **길이** | 제한 없음, 단 꼭 **1줄 요약 (TL;DR)** 을 포함해 주세요 |
| **포인트** | “무엇을 했다” 보다 **“왜 그렇게 판단했는가”** 중심 |
| **예시 포함** | 코드 비교, 흐름도, 리팩토링 전후 예시 등 자유롭게 |
| **톤** | 실력은 보이지만, 자만하지 않고, **고민이 읽히는 글**예: “처음엔 mock으로 충분하다고 생각했지만, 나중에 fake로 교체하게 된 이유는…” |

---

### ✨ 좋은 톤은 이런 느낌이에요

> 내가 겪은 실전적 고민을 다른 개발자도 공감할 수 있게 풀어내자
>

| 특징 | 예시 |
| --- | --- |
| 🤔 내 언어로 설명한 개념 | Stub과 Mock의 차이를 이번 주문 테스트에서 처음 실감했다 |
| 💭 판단 흐름이 드러나는 글 | 처음엔 도메인을 나누지 않았는데, 테스트가 어려워지며 분리했다 |
| 📐 정보 나열보다 인사이트 중심 | 테스트는 작성했지만, 구조는 만족스럽지 않다. 다음엔… |

### ❌ 피해야 할 스타일

| 예시 | 이유 |
| --- | --- |
| 많이 부족했고, 반성합니다… | 회고가 아니라 일기처럼 보입니다 |
| Stub은 응답을 지정하고… | 내 생각이 아닌 요약문처럼 보입니다 |
| 테스트가 진리다 | 너무 단정적이거나 오만해 보입니다 |

### 🎯 Feature Suggestions

- 누적 랭킹만 유지하면 왜 **롱테일 문제**가 발생할까?
- **시간의 양자화..** 처음 보는 너, 대체 왜 필요하니?
- **콜드스타트(0점에서 시작)** 문제를 어떻게 풀 수 있을까?
- 우리의 **랭킹 지표**는 이렇게 구성되요. 진짜 **인기있는 상품**은 이런 거예요.
- **실시간 랭킹?** 어려워 보이죠? 이렇게 풀면 쉽다!