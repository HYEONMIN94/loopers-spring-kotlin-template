## 🧭 루프팩 BE L2 - Round 9

> 우리는 이제, 유저가 우리 서비스에서 더 좋은 상품을 탐색할 수 있도록 상품 랭킹을 제공할 거예요.

이전에는 Key-value store, Cache store 용도로 써봤던 **Redis** 의 다른 자료형, `ZSET` ( Sorted Set ) 을 활용해 볼 겁니다. **ZSET 기반**으로 시그널들을 모아 랭킹 점수를 반영하고, API 는 이 데이터를 기반으로 TOP-N API, 개별 상품 순위 정보를 제공합니다.
>

<aside>
🎯

**Summary**

</aside>

지난 라운드에서 Kafka 를 통해 이벤트를 발행하고, 컨슈머가 후속 처리를 담당하도록 하여 서비스 경계를 넘어서는 확장성을 확보할 방법에 대해 학습했습니다.

이번 라운드에서는 **Redis ZSET** 을 활용해 실시간 랭킹 기능을 구현합니다. **컨슈머**는 이벤트를 소비해 ZSET 점수를 갱신하고, **API** 는 ZSET 을 조회해 랭킹 기능을 제공하도록 설계합니다.

<aside>
📌

**Keywords**

</aside>

- Redis Sorted Set (ZSET)
- ZINCRBY 기반 실시간 집계
- Top-N API
- 일별 Key 전략 & TTL
- 콜드 스타트 문제

<aside>
🧠

**Learning**

</aside>

## 📊 Ranking System

<aside>
💡

**Ranking** 시스템의 특성은 뭐가 있을까요?

- 랭킹 정보가 많이 요청됨
    - **Top-N API :** 항상 유저에게 인기 있는 지면이자 다양한 큐레이션 요소로 활용

      > 홈 메인 - 인기 상품, 오늘의 Top 10, 인기순 정렬 등
    >
    - **개별 순위 조회 :** 특정 상품이 현재 몇 위인지 표기할 때 활용
- 주기적인 갱신이 필요함
    - 일간, 주간, 월간 단위로 새롭게 시작되는 랭킹 구조 필요 **(이번엔 일간만 진행)**
    - **콜드 스타트 문제**가 존재할 수 있음
- **RDB** 로 해결하면 안되는 걸까?
    - DB 쿼리 (`GROUP BY + ORDER BY`)  는 데이터가 쌓일수록 느려짐
    - 조회 빈도가 매우 높아 DB 과부하로 이어질 수 있음
</aside>

### 📈 Redis ZSET

> 이전에 캐시를 위해 **Strings 자료형**을 사용해 보았다면, 이번에는 **SortedSet 자료구조**를 활용해볼 예정입니다.
>
- **ZSET 구조**
    - `(member, score)` 쌍을 score 기준으로 정렬된 상태로 유지함
    - **삽입/수정** : O(logN)
    - **Top-N 조회** : O(N)
- **주요 연산**
    - `ZADD key score member` : score 와 함께 member 저장 (이미 있을 경우 갱신됨)
    - `ZREVRANGE key 0 N WITHSCORES` : score 기준 Top-N 조회
    - `ZREVRANK key member` : 특정 멤버의 순위 조회
    - `ZSCORE key member` : 특정 멤버의 스코어 조회
    - `ZCARD key` : 멤버 수 조회
- **Why ZSET ?**
    - 정렬 기능이 내장되어 있어 별도 인덱스 등에 대한 설정 불필요
    - 실시간으로 랭킹 반영 가능
    - 다양한 조회 지원 : Top-N, 특정 `member` 의 순위, score 범위 검색 등
- **다른 방식과 비교**


    | 방법 | 장점 | 단점 | 적합도 |
    | --- | --- | --- | --- |
    | DB ORDER BY | 정합성 ↑ | 느림, 부하 ↑ | 초기/소규모 |
    | 캐시(Map) + 정렬 | 간단 | 매 요청마다 정렬 필요 | 중간 |
    | Redis ZSET | 빠른 정렬 내장, 다양한 조회 지원 | 메모리 사용 ↑ | 대규모 트래픽 |

### 🔑 Key 설계 - 시간의 양자화

<aside>
💡

**Key 설계는 왜 중요할까요?**

랭킹은 언제부터 언제까지의 집계인지가 명확해야 의미가 있어요.

**타임 윈도우 별로 키를 분리**하면 랭킹 데이터에 대한 리셋, 만료, 보정 등 운영을 하기 좋습니다.

즉, 단순 누적만 할 경우 **랭킹의 의미가 퇴색**될 수 있어요.

</aside>

- **누적만 할 경우의 문제**
    - 오래 전 점수를 쌓은 상품이 계속 상위에 노출됨 → 신상품은 노출될 기회가 사라짐
    - 결국 **롱테일 (Long Tail) 현상** 이 나타나고, 소수 상품이 인기 상위권을 독식하게 됨
    - 특정 시간 단위 집계로 **공정성을 확보**하고 신선한 정보를 노출해야 함
- **시간의 양자화**
    - 집계를 일정 단위 (시간, 일, 주, 월 등) 으로 나누어서 관리
    - **일간 집계** - 하루 단위로 랭킹을 관리할 수 있어야 함 → 오늘 점수와 어제 점수를 분리
    - **TTL** - 메모리 관리를 위해 시간 윈도우의 1.5배~2배 정도로 잡으면 안정적
- 예시

    ```java
    rank:all:20250906 // 9월 6일 랭킹 집계
    rank:all:20250907 // 9월 7일 랭킹 집계
    ```


## ⚖️ 가중치 합산 (Weighted Sum)

<aside>
💡

**왜 가중치가 필요한가요?**
(1) 좋아요/구매/매출액은 스케일이 달라 단순 합산 시 특정 지표가 지배  
(2) 서비스 전략에 따라 어떤 지표를 더 중요하게 볼지 달라짐

</aside>

- **총점식**

    ```java
    Sum(p) = W(like)*Count(p.like) + W(order)*Count(p.order) + W(view)*Count(p.view)
    
    * W : Weight (가중치)
    * Count : 스코어를 구성하는 요소 수
    ```

- **기본 가중치 예시**
    - **Weight(view) = 0.1**
        - 조회 수는 가장 많을 것이므로 전체 스코어를 잡아먹을 수 있음
    - **Weight(like) = 0.2**
        - 좋아요 수는 주문 수보다는 **구매 결정** 관점에서 덜 중요한 지표이므로 조금 낮게 설정
    - **Weight(order)** = 0.7
        - 주문 수는 유저가 구매를 결정했으므로 가장 중요한 지표라고 보고 가중치를 높게 설정

### ❄️ 콜드 스타트 문**제**

<aside>
⚠️

**콜드 스타트 ?**

집계 윈도우가 시작되는 시점에는 아직 점수가 쌓이지 않았을 수 있기 때문에 랭킹정보가 존재하지 않거나 대상이 부족하게 됩니다.

즉, 랭킹 정보를 위해 ZSET 을 조회했지만 **상품 목록이 없는 문제** 가 생기게 되죠. 전날 인기 있었던 상품도, 새벽에 들어온 신상품도 동일한 조건으로 시작하는 문제가 발생해요.

혹은 랭킹에 진입하지 못한 상품들은 자연스레 **클릭도 구매도 발생하지 않게 되는 악순환**으로 이어질 수도 있습니다.

</aside>

**문제점**

- 윈도우가 변경되는 시점에는 대부분 상품 점수가 0이므로 **랭킹이 의미 없어짐**
- 사용자에게는 **어제 인기 있었던 상품** 또한 랭킹에서 보길 기대할 수 있음

### 🔄 **해결**

- **Score Carry-Over**
    - 새로운 키 생성 시 전날 점수의 일부를 적은 가중치를 곱해 미리 복사함
    - 이 떄, 가중치는 작은 값으로 가져가 오늘의 점수가 상위로 올라가지 못하는 문제를 방지

    ```java
    ZUNIONSTORE ranking:all:20250907 1 ranking:all:20250906 WEIGHTS 0.1 AGGREGATE SUM
    
    `ranking:all:20250907` 로 `ranking:all:20250906` 의 스코어들에 0.1 을 곱해서 복사
    ```


### 📊 Before / After Score

**Before (20250906)**

```
product:101 → 100
product:202 → 50
```

**After (20250907, carry-over 10%)**

```
product:101 → 10
product:202 → 5
```

---

<aside>
📚

**References**

</aside>

| 구분 | 링크 |
| --- | --- |
| 🔍 Redis Sorted Sets | [RedisGate - SORTED SETS](https://redisgate.kr/redis/command/zsets.php) |
| ⚙ Spring Data Redis | [Spring Data Redis - Redis Template](https://docs.spring.io/spring-data/redis/reference/redis/template.html) |
| 📖 Redis Sorted Set을 이용한 랭킹 관리 | [Medium - Redis Sorted Set을 이용한 랭킹 관리](https://medium.com/sjk5766/redis-sorted-set%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%9E%AD%ED%82%B9-%EA%B4%80%EB%A6%AC-38d28712a8b9) |

<aside>
🌟

**Next Week Preview**

</aside>

> **일간을 넘어서 주간/월간 집계를 만들려면 어떻게 하는 게 좋을까?**
>
>
>
> 이번 주차에는 **Redis ZSET 을 기반으로 랭킹 시스템을 구축**할 방법에 대해 고민해 보았습니다. 유저에게 어떻게 랭킹 시스템을 제공할 수 있을까라는 고민을 통해 **인기 있는 상품을 효율적으로 노출**할 수 있게 되었어요.
>
> 이제는 일간 집계를 활용해 주간 집계 데이터를 만들고, 월간 집계 데이터를 만들기 위해선 어떻게 해야할까 고민해볼 거예요. 차주에는 점차 많아지는 데이터나 통계들을 주기적으로 생성해내는 기능을 만들어 봅니다.
>